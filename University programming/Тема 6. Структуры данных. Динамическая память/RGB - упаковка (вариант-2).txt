/*Во многих DSP-процессорах и микроконтроллерах все типы данных имеют одинаковую размерность, равную длине машинного слова (например, 32 бита). Поэтому все обрабатываемые данные хранятся в 32-разрядных ячейках памяти.

На вход поступает последовательность (массив) пикселов цветного изображения в формате RRGGBB, упакованная в 32-разрядные слова: RRGGBBRR GGBBRRGG BBRRGGBB (то есть в каждом 32-разрядом слове есть 8-разрядные поля, относящиеся к двум соседним пикселам).

Соотношение числа 32-разрядных слов N и числа пикселов M таково, что массив заполнен полностью и все пикселы поместились целиком. Сформируйте массив из M отсчетов, где для каждого пиксела будет записана его яркость:

Y = 0.299*RR + 0.587*GG + 0.114*BB



Пояснение. Иллюстрация входных данных для массива из 3-х 32-разрядных отсчетов. Внимание! Порядок отсчетов массива для наглядности показан справа-налево (в реальности порядок поступления отсчетов массива на вход программы таков: BB2RR1GG1BB1, GG3BB3RR2GG2, RR4GG4BB4RR3).

RR4 GG4 BB4 RR3     GG3 BB3 RR2 GG2      BB2 RR1 GG1 BB1

В каждом отсчете есть цветовые поля, соответствующие двум соседним пикселам: RR1GG1BB1 - первый пиксел, RR2GG2BB2 - второй пиксел, RR3GG3BB3 - третий пиксел, RR4GG4BB4 - четвертый пиксел.

Таким образом, четыре 24-разрядных пиксела упакованы в три 32-разрядных отсчета.

Необходимо последовательно "вытащить" 3х8 битов, соответствующих каждому пикселу, и для них вычислить яркость Y.*/
// 21.12.2023

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

const float coef[] = { 0.299, 0.587, 0.144 };



/*

Хранит данные типа unsigned char для выделения двух бит

*/

struct RGB {

	unsigned char r;

	unsigned char g;

	unsigned char b;

};

/* На вход подается число n - количество вводимых в шестнадцатиричном формате чисел.

Количество n кратно 3, тк количество занчений типа unsigned int == 3.

* 6

* 0x02010101 0x03030202 0x04040403 0x06050505 0x07070606 0x08080807

* каждое число хранится перевернутым,

* например: 02010101 хранится как 01010102.

*  все хранится как {01010102} {02020303} {03040404} {05050506} {06060707} {07080808}

*  далее это значение переводится через union в unsigned char:

* {r01 g01 b01} {r02 g02 b02} {r03 g03 b03} {r04 g04 b04} и тд.

* для каждого единичного чара вычисляется яркость, их значения складываются в общее

* значение, которое записывается в массив

* массив выводится

*/





/*

 Структура типа union, которая накладывает типы unsigned int и unsigned char

*/

typedef union rgb {

	unsigned int pix[3];

	struct RGB s[4];

}t_rgb;



int main() {

	int n, m;

	t_rgb pixels[300];

	int arr[4];

	scanf("%d", &n);

	for (int i = 0; i < n; i+=3) {

		scanf("%i %i %i", &pixels[i].pix[0], &pixels[i].pix[1], &pixels[i].pix[2]);

		for (int j = 0; j < 4; j++) {

			arr[j] = pixels[i].s[j].r * coef[0] + pixels[i].s[j].g * coef[1] + pixels[i].s[j].b * coef[2];

		}

		printf("%d %d %d %d\n", arr[0], arr[1], arr[2], arr[3]);

	}

	return 0;

}

